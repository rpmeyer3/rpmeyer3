_> CSCI 2670 - Classwork 11
__ <!> Instructions
|> Create a \graf document with your answers to the following problems.  Save your work as a Grafstate file with the extension **{.graf.txt} and upload it to eLC.
|> You may work in small groups.  You must identify your group on eLC.
|> Only one student in the group should do the eLC  submission.
|> Look at your file when you save it and *{before} submitting it to eLC to make sure it is what you intend to submit.  Check eLC *{after} submitting your file to make sure the correct file was uploaded.  It is your responsibility to submit the correct file.
|> The last version of your answer file that you submit before the deadline is the one that will be graded. If you submit the wrong file and submit a replacement after the deadline, then the usual late policy will apply.
|>  All Grafstate files should compile when the TA loads them into the Grafstate Shell. A file that does not compile will not be graded.
@{*}All TMs must be deterministic.
\;
Group members:
1.)_____________________
2.)_____________________
3.)_____________________
4.)_____________________
5.)_____________________
\;
@{*} Refer to Grafstate Margin Notes Section 3.5 and 3.6 for descriptions and examples on enumerators and computable functions.
@{*} To receive full credit, you must comment your transitions.
\;
(1) Create a Turing machine to compute the @fn
>< f(n)=n+1,
> where n is a binary number.
1. Start in q0 on the left most symbol of the input tape
2. if current symbol is 0 write 1 and halt, if the current symbol is 1 replace it with a zero and move right
3. repeat step 2 until a 0 is written
4 move until a 1 is found
5. replace the 1 with a 0 and move right until the input tape is reached
6. write a 1 on the tape and halt
//
:+ tm IncrementBinary
Q = {q0, q1, qa}
S = {0, 1}
T = {0, 1, \_}
q0 = q0
tapes = 2
q0 -> qa : 0, S ; 1, S       /* If reading '0', replace with '1' and accept (no carry needed) */
q0 -> q1 : 1, S ; 0, R       /* If reading '1', replace with '0' (carry), move right */
q1 : 1, S ; 0, R             /* If in q1, reading '1', replace with '0' (continue carry), move right */
q1 -> qa : 0, S ; 1, S       /* If in q1, reading '0', replace with '1' (carry resolved), accept */
q1 -> qa :\_, S ; 1, S       /* If end of tape reached in q1, write '1' to handle overflow, accept */
done.
//
//
(2) Create a mapping Turing machine to compute the @fn
>< f(n)=2n,
> where n is a binary number.
1. Start in state q0 with the read/write head at the leftmost symbol of the input.
2. If the current symbol is 0, write 0 and move the head to the right. If the current symbol is 1, write 1 and move the head to the right.
3. Repeat step 2 until the end of the input is reached.
4. Move the head to the leftmost symbol of the output.
5. Repeat the following steps until the end of the output is reached:
a. If the current symbol is 0, write 0 and move the head to the right. If the current symbol is 1, write 1 and move the head to the right.
b. If the current symbol is blank, write 0 and move the head to the right.
6. Halt in the final state qf.
//
:+ tm DoubleBinary
Q = {q0, q1, q2, q3, qf}
S = {0, 1}
T = {0, 1, \_}
q0 = q0
tapes = 2

/* Step 1: Copy each bit of the input to the output */
q0 -> q1 : 0, S ; 0, R      /* If reading '0', copy '0' to output and move right */
q0 -> q1 : 1, S ; 1, R      /* If reading '1', copy '1' to output and move right */
q0 -> q2 : \_, S ; \_, L      /* If blank is reached, start the doubling process */

/* Step 2: Move back to the start of the output */
q2 : 0, S ; 0, L            /* Move left over copied '0's */
q2 : 1, S ; 1, L            /* Move left over copied '1's */
q2 -> q3 : \_, S ; \_, R      /* When reaching left end, prepare to shift left */

/* Step 3: Append '0' at the end (doubling) */
q3 : 0, S ; 0, R            /* Move right over all copied '0's */
q3 : 1, S ; 1, R            /* Move right over all copied '1's */
q3 -> qf : \_, S ; 0, S      /* Write '0' at the end, halt */

done.
//
:+ tm CustomMachine
Q = {q0, q1, q2, q3, q4, qf}
S = {0, 1}
T = {0, 1, \_}
q0 = q0
tapes = 2

/* Transition definitions */
q0 -> q1 : 0, S ; 0, R             /* If in q0 reading '0', write '0', move right, go to q1 */
q0 -> q1 : 1, S ; 1, R             /* If in q0 reading '1', write '1', move right, go to q1 */

q1 -> q2 : 0, S ; 0, R             /* If in q1 reading '0', write '0', move right, go to q2 */
q1 -> q2 : 1, S ; 1, R             /* If in q1 reading '1', write '1', move right, go to q2 */

q2 -> q3 : 0, S ; 1, L             /* If in q2 reading '0', write '1', move left, go to q3 */
q2 -> q3 : 1, S ; 0, R             /* If in q2 reading '1', write '0', move right, go to q3 */
q2 -> q3 : \_, S ; 0, R         /* If in q2 reading blank, write '0', move right, go to q3 */

q3 -> q4 : 0, S ; 0, L             /* If in q3 reading '0', stay on '0', move left, go to q4 */
q3 -> q4 : 1, S ; 1, L             /* If in q3 reading '1', stay on '1', move left, go to q4 */
q3 -> qf : \_, S ; 0, R         /* If in q3 reading blank, write '0', move right, halt in qf */

q4 -> q2 : 0, S ; 1, R             /* If in q4 reading '0', write '1', move right, go to q2 */
q4 -> q2 : 1, S ; 0, R             /* If in q4 reading '1', write '0', move right, go to q2 */

done.
//
//
(3) Write the \graf code for a Turing machine that enumerates the @lang L={a^nb^{2n}|n\ge0}.
//
:+ tm Ma
Q = {q1, q2, q3, q4, q5, q6, q7, q8, q9}
S = {a, b}
T = {a, b, \_, #}
q0 = q1 
tapes = 2
q1 -> q2: \_, R; a, R  /* Write the first 'a' to tape 2*/
q2 -> q3: a, R; a, R  /*  Write the subsequent 'a's to tape 2*/
q3 -> q4: \_, R; #, R   /*  Write the separator '#' to tape 2 */
q4 -> q5: \_, R; b, R   /*  Write the first 'b' to tape 2 */
q5 -> q6: b, R; b, R   /*  Write the subsequent 'b's to tape 2 */
q6 -> q7: \_, L; \_, L   /*  Move the head to the beginning of tape 2 */
q7 -> q8: #, L; #, L   /*  Move the head to the beginning of tape 1 */
q8 -> q9: \_, R; \_, R   /*  Halt and output the string */
done.
//
//
(4) Write the \graf code for a Turing machine that enumerates the @lang described by the @regex (ab)*
//
:+ tm SimpleMachine
Q = {q0, q1, q2, q3, q4}
S = {a, b}
T = {a, b, \_}
q0 = q0
tapes = 2

/* Transition definitions */
q0 -> q1 : a, S ; a, R           /* If in q0 and reading 'a', stay on 'a' and move right, go to q1 */
q1 -> q2 : b, S ; b, R           /* If in q1 and reading 'b', stay on 'b' and move right, go to q2 */
q2 -> q0 : a, S ; a, R           /* If in q2 and reading 'a', stay on 'a' and move right, return to q0 */
q0 -> q3 : \_, S ; \_, S           /* If in q0 and reading blank, transition to reject state q3 and halt */

done.