_> CSCI 2670 - Classwork 7
__ <!> Instructions
|> Create a \graf document with your answers to the following problems.  Save your work as a Grafstate file with the extension **{.graf.txt} and upload it to eLC.
|> You may work in small groups.  You must identify your group on eLC.
|> Only one student in the group should do the eLC  submission.
|> Look at your file when you save it and *{before} submitting it to eLC to make sure it is what you intend to submit.  Check eLC *{after} submitting your file to make sure the correct file was uploaded.  It is your responsibility to submit the correct file.
|> The last version of your answer file that you submit before the deadline is the one that will be graded. If you submit the wrong file and submit a replacement after the deadline, then the usual late policy will apply.
|>  All computational structures (i.e., automata and grammars) should be coded using Grafstate \[:+] syntax. Working automata code should produce a state diagram.
|>  All Grafstate files should compile when the TA loads them into the Grafstate Shell. A file that does not compile will not be graded.
\;
Group members:
1.)_____________________
2.)_____________________
3.)_____________________
4.)_____________________
5.)_____________________
\;
__ <!> You can use the format below to create a table in Grafstate:
//
//
//
//
:fig table
x # x^2 # x^3
1 # 1 # 1
2 # 4 # 8
3 # 9 # 27
done.
//
//
//
//
__ @{task} Exercises
(1) Consider the below CFG.
//
//
//
:+ cfg G1
V={S,B,C}
S={a,b,c}
v0=S
S -> a S a |B
B -> b b C | b b |\e
C -> c C| \e
done.
//
//
//
(a) What is Step 01 in converting a CFG to CNF? Apply Step 01 and create the new CFG, G2.
For B ⟶ ε:
Replace B in S ⟶ B: S ⟶ ε
Replace B in B ⟶ bb: No change needed, as B’s are not removed if B produces ε itself
For C ⟶ ε:
Replace C in B ⟶ bbC: B ⟶ bb, B ⟶ bbC (bb is already there)
So, after eliminating null productions:
S ⟶ aSa | B | ε
B ⟶ bbC | bb | ε
C ⟶ cC | ε
(b) What is Step 02 in converting a CFG to CNF? Apply Step 02 and create the new CFG, G3.
For S ⟶ B:
Replace B in S ⟶ B: S ⟶ bbC | bb | ε
S already has its rules in place:
S ⟶ aSa | bbC | bb | ε
(c) What is Step 03 in converting a CFG to CNF? Apply Step 03 and create the new CFG, G4.
All non-terminals (S, B, C) are reachable from S.
All generate terminal strings:
S ⟶ aSa | bbC | bb | ε
B ⟶ bbC | bb
C ⟶ cC | ε
G4 is the same as G3 I believe
(d) What is Step 04 in converting a CFG to CNF? Apply Step 04 and create the new CFG, G5.
S ⟶ aSa | bbC | bb | ε (aSa is not in CNF)
Introduce a new variable: S1 ⟶ aS
Replace S ⟶ aSa with S ⟶ S1a New rule: S1 ⟶ aS
B ⟶ bbC | bb (bbC is not in CNF)
Introduce a new variable: B1 ⟶ bb
Replace B ⟶ bbC with B ⟶ B1C New rule: B1 ⟶ bb
So, G5:
S ⟶ S1a | B | bb | ε
B ⟶ B1C | bb
C ⟶ cC | ε
S1 ⟶ aS
B1 ⟶ bb
(e) What is Step 05 in converting a CFG to CNF? Apply Step 05 and create the new CFG, G6.
Remove ε from S ⟶ S1a | B | bb | ε (as ε is not allowed in CNF, but only if S does not lead to ε directly):
Resulting G6:
S ⟶ S1a | B | bb
B ⟶ B1C | bb
C ⟶ cC | ε
S1 ⟶ aS
B1 ⟶ bb
\;
(2) Consider the @fllwng CFG in CNF:
//
//
//
:+ cfg G7
V={S,X, Y,A, B}
v0=S
S={a,b}
S-> X B | X A
X->B Y | A B | a
Y->b | B Y
A->a
B->b
done.
//
(a) Use the CYK algorithm to demonstrate that that the string @{[bbba]} is derived by G7.  Show the entire CYK table.
//
:fig table
G7 #1 #2 #3 #4
1 #B #B #B #A
2 #-- #B,Y #B,Y #--
3 #-- #-- #X,B #X,A
4 #-- #-- #-- #S
done.
//
For b (index 1, 2, 3): Only B produces b.
For a (index 4): Only A produces a
For length 2 substrings:
"bb" (1-2): B ⟶ b and B ⟶ B Y
"bb" (2-3): Same as above.
"ba" (3-4): Nothing directly matches "ba," but we can find B ⟶ b, A ⟶ a.
For length 3 substrings:
"bbb" (1-3): No direct match. Consider substrings: "bb" and "b" which map to B and Y.
"bba" (2-4): No direct match. Consider substrings: "bb" and "a" which map to X and A.
For the complete string "bbba":
"bbb" and "a" which give us X ⟶ b Y and A ⟶ a.
S ⟶ X B and X maps to the first part "bbb".
so the string bbba can be derived from G7 using the CYK algorithm/
//
\;
(b) Use the CYK algorithm to demonstrate that that the string @{[abba]} is not derived by G7.  Show the entire CYK table.
//
:fig table
G7 #1 #2 #3 #4
1 #A #B #B #A
2 #-- #B,Y #B,Y #--
3 #-- #-- #X,B #X,A
4 #-- #-- #-- #--
done.
//
For a (index 1, 4): Only A produces a.
For b (index 2, 3): Only B produces b.
For length 2 substrings:
"ab" (1-2): Nothing directly matches "ab".
"bb" (2-3): B ⟶ b and B ⟶ B Y
"ba" (3-4): Nothing directly matches "ba".
For length 3 substrings:
"abb" (1-3): No direct match. Consider substrings: "ab" and "b" which don't map correctly.
"bba" (2-4): No direct match. Consider substrings: "bb" and "a" which map to X and A.
For the complete string "abba":
"ab" and "ba," both of which don't conform to rules.
Since we cannot derive the entire string "abba" from the initial variable S through any valid combinations, "abba" is not derived by G7.