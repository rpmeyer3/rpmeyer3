5.) q_4->q_3->q_2->q_1
(a\u (ba*b(a\ubb*a)))*ba*\uba*b
approximate length: 27 characters
q_1->q_4->q_3->q_2
aba* \u a*ba*b ((bb*(aa*b) \u aa*b)a*b)*
approximate length: 33

b.)  The two lenghts arent terribly different, there was an alternative one that we saw had 53 characters, patterns where q_4 or q_1 are one of the first  two states removed there are a  couple more expressions added in order to move betweeen states upon removal. To compare the lengths of resulting regular expressions and identify any patterns in the removal order that led to shorter or longer expressions, we need to start by identifying the original regular expressions before any removal or simplification. Next, we apply different removal or simplification techniques to these regular expressions and measure the lengths of the resulting expressions using a consistent method, such as character count or token count. By comparing the lengths of the original and resulting regular expressions, we can observe whether there are significant differences. For example, in the case of the original regular expression (a|b)*c and its simplified form a*c|b*c, the simplified version is slightly longer, with 7 characters compared to the original’s 6 characters. This suggests that the removal of groupings and the use of the alternation operator | may not always result in shorter expressions. Identifying such patterns can help us understand the impact of different removal or simplification techniques on the length of regular expressions. Over time these differences add up creating the difference that we see.

c.)  A useful heuristic for choosing the order of state removal to achieve simpler regular expressions is to remove states with the fewest incoming and outgoing transitions first. The reasoning behind this is that states with fewer transitions are less interconnected with other states, making their removal less likely to introduce complex regular expressions. By starting with these simpler states, the resulting regular expressions are more likely to remain manageable and less convoluted. Additionally, prioritizing the removal of states that do not significantly contribute to the overall structure of the automaton can help maintain simplicity. For example, states that primarily serve as intermediate steps without many branching paths can be good candidates for early removal. focusing on states with minimal transitions and those that are less central to the automaton’s structure can help produce simpler regular expressions during the state removal process.